#!/usr/bin/env python

"""
Test a continuel trajactory that is generated by FK, e.t., it is a arrivable trajactory.
As PyKDL is built with python2, these codes use python2 too.
"""

# system
from __future__ import print_function
from cProfile import label
import pathlib
from scipy.optimize._lsq.least_squares import prepare_bounds
from time import sleep, time
import threading
import sys
import copy


# math
import numpy as np
np.set_printoptions(suppress=True, linewidth=200) # suppress=True, 
# with this, values will be printed without scientific notation
import math
from scipy.optimize.nonlin import Jacobian
from scipy.spatial.transform import Rotation
from scipy.spatial.transform import Slerp
from scipy.optimize import minimize, least_squares, leastsq, curve_fit
from scipy import odr
import matplotlib.pyplot as plt

# ROS
import rospy
from geometry_msgs.msg import Pose, Point, Quaternion
from urdf_parser_py.urdf import URDF
import PyKDL as kdl
from pykdl_utils.kdl_parser import kdl_tree_from_urdf_model
from pykdl_utils.kdl_kinematics import KDLKinematics


"""
import moveit_commander
import moveit_msgs.msg
from moveit_commander.conversions import pose_to_list
"""


# self-defined functions
from lhz_func import T2pose, find_vec_from_text, pose2T, wxyz2xyzw, xyzw2wxyz, average_quaternions, pose_quat2new_ros_pose, ros_pose2new_pose_quat, kdl_calc_fk, kdl_finger_twist2qvel, angular_vel_from_quats, cross_product_matrix_from_vector3d, quats2delta_angle_degrees, quats2delta_angle, T2AdT, pR2AdT, delta_pose2next_pose, R2delta_angle


# self-defined msg
from allegro_ur_ctrl_cmd.msg import allegro_hand_joints_cmd, ur_ee_cmd
from allegro_tactile_sensor.msg import tactile_msgs

class MyController(object):
    # pose estimation: static variable _k_e
    _k_e = 500.0
    # For subscribe and calculating
    def __init__(self):
        self.this_file_dir = str(pathlib.Path(__file__).parent.absolute())
        print("Task:\nTest IK!\n")
        print("This script dir:", self.this_file_dir)
        if len(sys.argv) == 2:
            if sys.argv[1] == "sim":
                self.sim_flag = True
                print("Starting calculations for simulation ...")
            else:
                raise ValueError("Unexpected argument! If sim, argument should be \"sim\", else, type nothing")
        elif len(sys.argv) == 1:
            self.sim_flag = False
            print("Starting calculations for real machine ...")
        else:
            raise ValueError("Number of arguments should be 0 or 1.")
        self.index_tacxel_pose = np.loadtxt(self.this_file_dir+"/allegro_tactile_description/index_tacxel_pose_20211220.txt")
        self.index_tacxel_pose_euler = np.zeros((np.size(self.index_tacxel_pose,0),6))
        for i in range(np.size(self.index_tacxel_pose,0)):
            self.index_tacxel_pose_euler[i,:3] = self.index_tacxel_pose[i,:3].copy()
            self.index_tacxel_pose_euler[i,3:] = Rotation.from_quat(self.index_tacxel_pose[i,3:]).as_euler("XYZ", degrees=False)

        # CMD
        self.joint_pos_cmd = np.zeros(16)
        self.ee_pos_cmd = np.zeros(3)
        self.ee_quat_cmd = np.zeros(4)
        # allegro hand joints cmd
        self.allegro_publisher = rospy.Publisher('/allegro_joints_cmd', allegro_hand_joints_cmd, queue_size=10) # Think twice about the queue_size, it should be determined by control rate
        self.jcmd_pub = allegro_hand_joints_cmd()
        self.jcmd_pub.header.seq = 0
        self.jcmd_pub.header.stamp = rospy.Time.now()
        # ur endpoint pose cmd
        self.ur_publisher = rospy.Publisher('/ur_eepose_cmd', ur_ee_cmd, queue_size=10) # Think twice about the queue_size, it should be determined by control rate
        self.urcmd_pub = ur_ee_cmd()
        self.urcmd_pub.header.seq = 0
        self.urcmd_pub.header.stamp = rospy.Time.now()

        self.index_goal_publisher = rospy.Publisher('/index_goal', ur_ee_cmd, queue_size=10) # Think twice about the queue_size, it should be determined by control rate
        self.index_goal_pub = ur_ee_cmd()
        self.thumb_goal_publisher = rospy.Publisher('/thumb_goal', ur_ee_cmd, queue_size=10) # Think twice about the queue_size, it should be determined by control rate
        self.thumb_goal_pub = ur_ee_cmd()

        # init callback variables
        self.jstate_seq = 0
        self.jstate_secs = 0
        self.jstate_nsecs = 0
        self.eestate_seq = 0
        self.eestate_secs = 0
        self.eestate_nsecs = 0
        self.allegro_jstates = np.zeros(16)

        self.index_weights = np.mat(np.zeros((4,1)))
        self.mid_weights = np.mat(np.zeros((4,1)))
        self.ring_weights = np.mat(np.zeros((4,1)))
        self.thumb_weights = np.mat(np.zeros((4,1)))
        self.j_limits = np.mat(np.loadtxt(self.this_file_dir+"/allegro_tactile_description/allegro_joint_limits_20220206.txt"))
        # self.j_limits is a matrix saving the joint limits of the Allegro Hand:
        # self.j_limits[0,:] saves the upper limits, self.j_limits[1,:] saves the lower limits
        # e.g., self.j_limits[0,15] saves the upper limit of the 16th joint (tip joint of the thumb)
        self.index_limits = self.j_limits[:,0:4]
        self.mid_limits = self.j_limits[:,4:8]
        self.ring_limits = self.j_limits[:,8:12]
        self.thumb_limits = self.j_limits[:,12:16]
        self.index_ranges = np.mat(np.zeros((1,4)))
        self.mid_ranges = np.mat(np.zeros((1,4)))
        self.ring_ranges = np.mat(np.zeros((1,4)))
        self.thumb_ranges = np.mat(np.zeros((1,4)))
        self.index_ranges = self.index_limits[0,:] - self.index_limits[1,:]
        self.mid_ranges = self.mid_limits[0,:] - self.mid_limits[1,:]
        self.ring_ranges = self.ring_limits[0,:] - self.ring_limits[1,:]
        self.thumb_ranges = self.thumb_limits[0,:] - self.thumb_limits[1,:]
        self.index_ranges_sq = self.index_ranges
        self.mid_ranges_sq = self.mid_ranges
        self.ring_ranges_sq = self.ring_ranges
        self.thumb_ranges_sq = self.thumb_ranges
        for i in range(4):
            self.index_ranges_sq[0,i] = (self.index_ranges[0,i]**2)/4.0
            self.mid_ranges_sq[0,i] = (self.mid_ranges[0,i]**2)/4.0
            self.ring_ranges_sq[0,i] = (self.ring_ranges[0,i]**2)/4.0
            self.thumb_ranges_sq[0,i] = (self.thumb_ranges[0,i]**2)/4.0


        self.ur_eestates = np.zeros(7)
        self.jstate_dt = 0.0
        self.jstate_t0 = 0.0
        self.jstate_tt = 0.0
        self.urstate_dt = 0.0
        self.urstate_t0 = 0.0
        self.urstate_tt = 0.0
        self.index_tip = np.zeros(72)
        self.mid_tip = np.zeros(72)
        self.ring_tip = np.zeros(72)
        self.thumb_tip = np.zeros(72)
        self.current_time = time()

        # Timing and cmd, states init
        while not rospy.is_shutdown():
            print("Waiting for the first message from simulation...")
            jmsg = rospy.wait_for_message('/allegro_joints_state', allegro_hand_joints_cmd)
            eemsg = rospy.wait_for_message('/ur_eepose_state', ur_ee_cmd)
            if (jmsg.header.stamp != None) and (eemsg.pose != None):
                
                print("Received the first msg from \'/allegro_joints_state\'.")
                print("The message is\n", jmsg,"\n")
                print("Received the first msg from \'/ur_eepose_state\'.")
                print("The message is\n", eemsg,"\n")
                # self.joint_pos_cmd = jmsg.position
                # self.ee_pos_cmd[0] = eemsg.pose.position.x
                # self.ee_pos_cmd[1] = eemsg.pose.position.y
                # self.ee_pos_cmd[2] = eemsg.pose.position.z
                # self.ee_quat_cmd[0] = eemsg.pose.orientation.x
                # self.ee_quat_cmd[1] = eemsg.pose.orientation.y
                # self.ee_quat_cmd[2] = eemsg.pose.orientation.z
                # self.ee_quat_cmd[3] = eemsg.pose.orientation.w
                self.jcmd_pub = copy.deepcopy(jmsg)
                self.urcmd_pub = copy.deepcopy(eemsg)
                break
            rospy.sleep(0.01)
            # '/allegro_joints_state', allegro_hand_joints_cmd
        if self.sim_flag:
            self.last_time = float(jmsg.header.stamp.secs) + float(jmsg.header.stamp.nsecs)*1e-9
            self.current_time = float(jmsg.header.stamp.secs) + float(jmsg.header.stamp.nsecs)*1e-9
        else:
            self.last_time = time()
        # self.allegro_jstates[0] = jmsg.position[0]
        # self.allegro_jstates[1] = jmsg.position[1]
        # self.allegro_jstates[2] = jmsg.position[2]
        # self.allegro_jstates[3] = jmsg.position[3]
        # self.allegro_jstates[4] = jmsg.position[4]
        # self.allegro_jstates[5] = jmsg.position[5]
        # self.allegro_jstates[6] = jmsg.position[6]
        # self.allegro_jstates[7] = jmsg.position[7]
        # self.allegro_jstates[8] = jmsg.position[8]
        # self.allegro_jstates[9] = jmsg.position[9]
        # self.allegro_jstates[10] = jmsg.position[10]
        # self.allegro_jstates[11] = jmsg.position[11]
        # self.allegro_jstates[12] = jmsg.position[12]
        # self.allegro_jstates[13] = jmsg.position[13]
        # self.allegro_jstates[14] = jmsg.position[14]
        # self.allegro_jstates[15] = jmsg.position[15]
        self.allegro_jstates = np.array(copy.deepcopy(jmsg.position))
        # self.ur_eestates[0] = eemsg.pose.position.x
        # self.ur_eestates[1] = eemsg.pose.position.y
        # self.ur_eestates[2] = eemsg.pose.position.z
        # self.ur_eestates[3] = eemsg.pose.orientation.x
        # self.ur_eestates[4] = eemsg.pose.orientation.y
        # self.ur_eestates[5] = eemsg.pose.orientation.z
        # self.ur_eestates[6] = eemsg.pose.orientation.w
        self.ur_eestates = ros_pose2new_pose_quat(eemsg.pose)
        self.delta_time = 0.0

        # Save the first states, for safety use:
        self.init_allegro_jstates = copy.deepcopy(self.allegro_jstates)
        self.init_ur_eestates = copy.deepcopy(self.ur_eestates)
        print("self.ur_eestates:", self.ur_eestates)
        print("self.init_ur_eestates:", self.init_ur_eestates)
        print("self.init_allegro_jstates:", self.init_allegro_jstates)

        self.ry_hat_in_tip = np.zeros(4)
        self.rz_hat_in_tip = np.zeros(4)
        
        
        # urdf_parser and KDL
        # import URDF
        self.hand_description = URDF.from_xml_file(self.this_file_dir+"/allegro_tactile_description/allegro_hand_description_right_tactile_for_ik_viz.urdf")
        # allegro_hand_description_right_tactile_end
        # allegro_hand_description_right_tactile_for_ik_viz
        # create kdl_tree
        self.hand_tree = kdl_tree_from_urdf_model(self.hand_description)
        # init kdl_Frames for each finger
        self.index_pos = kdl.Frame() # Construct an identity frame
        self.index_pose = Pose()
        self.mid_pos = kdl.Frame() # Construct an identity frame
        self.ring_pos = kdl.Frame() # Construct an identity frame
        self.thumb_pos = kdl.Frame() # Construct an identity frame
        # init kdl_JntArrays for each finger
        self.index_qpos = kdl.JntArray(4)
        self.mid_qpos = kdl.JntArray(4)
        self.ring_qpos = kdl.JntArray(4)
        self.thumb_qpos = kdl.JntArray(4)

        self.index_qpos_d = kdl.JntArray(4)
        self.thumb_qpos_d = kdl.JntArray(4)
        kdl.SetToZero(self.index_qpos_d)
        kdl.SetToZero(self.thumb_qpos_d)

        kdl.SetToZero(self.index_qpos)
        kdl.SetToZero(self.mid_qpos)
        kdl.SetToZero(self.ring_qpos)
        kdl.SetToZero(self.thumb_qpos)
        # chain
        self.index_chain = self.hand_tree.getChain("palm_link", "index_tip_tactile")
        self.mid_chain = self.hand_tree.getChain("palm_link", "mid_tip_tactile")
        self.ring_chain = self.hand_tree.getChain("palm_link", "ring_tip_tactile")
        self.thumb_chain = self.hand_tree.getChain("palm_link", "thumb_tip_tactile")
        # forward kinematics
        self.index_fk = kdl.ChainFkSolverPos_recursive(self.index_chain)
        self.mid_fk = kdl.ChainFkSolverPos_recursive(self.mid_chain)
        self.ring_fk = kdl.ChainFkSolverPos_recursive(self.ring_chain)
        self.thumb_fk = kdl.ChainFkSolverPos_recursive(self.thumb_chain)
        # KDLKinematics
        self.index_kdl_kin = KDLKinematics(self.hand_description, "palm_link", "index_tip_tactile")
        self.mid_kdl_kin = KDLKinematics(self.hand_description, "palm_link", "mid_tip_tactile")
        self.ring_kdl_kin = KDLKinematics(self.hand_description, "palm_link", "ring_tip_tactile")
        self.thumb_kdl_kin = KDLKinematics(self.hand_description, "palm_link", "thumb_tip_tactile")
        # self.thumb2mid_kdl_kin = KDLKinematics(self.hand_description, "thumb_tip_tactile", "mid_tip_tactile")

        # pose estimation

        # moveit
        """
            moveit_commander.roscpp_initialize(sys.argv)
            self.hand = moveit_commander.RobotCommander()
            self.hand_scene = moveit_commander.PlanningSceneInterface()
            group_name = "right_index"
            self.hand_group = moveit_commander.MoveGroupCommander(group_name)
            self.planning_frame = self.hand_group.get_planning_frame()
            print("============ Planning frame: %s" % self.planning_frame)
            self.eef_link = self.hand_group.get_end_effector_link()
            print("============ End effector link: %s" % self.eef_link)
            group_names = self.hand.get_group_names()
            print ("============ Available Planning Groups:", self.hand.get_group_names())
            # Sometimes for debugging it is useful to print the entire state of the
            # robot:
            print ("============ Printing robot state")
            print (self.hand.get_current_state())
            print ("")
        """

        rospy.Subscriber('/allegro_joints_state', allegro_hand_joints_cmd, self.allegro_jstates_callback)
        rospy.Subscriber('/ur_eepose_state', ur_ee_cmd, self.ur_eestates_callback)
        rospy.Subscriber('allegro_tactile', tactile_msgs, self.allegro_tacstates_callback)

        

        # Threading
        # self.mutex = threading.Lock()
        self.ros_sub_thread = threading.Thread(target=self.loop)
        self.ros_sub_thread.start()
        # self.main_process_thread.join()

    def get_time(self):
        if self.sim_flag:
            self.current_time = float(self.jstate_secs + self.eestate_secs)*0.5 + float(self.jstate_nsecs + self.eestate_nsecs)*0.5*1e-9
        else:
            self.current_time = time()
        self.delta_time = self.current_time - self.last_time
        # print "tt=", self.current_time, "t0=", self.last_time, "dt=", self.delta_time
    def save_time(self):
        if self.sim_flag:
            self.last_time = self.current_time
        else:
            self.last_time = self.current_time

    def allegro_jstates_callback(self, msg):
        if msg.position != None:      
            self.allegro_jstates = np.array(msg.position)
            self.index_qpos[0] = self.allegro_jstates[0]
            self.index_qpos[1] = self.allegro_jstates[1]
            self.index_qpos[2] = self.allegro_jstates[2]
            self.index_qpos[3] = self.allegro_jstates[3]
            self.mid_qpos[0] = self.allegro_jstates[4]
            self.mid_qpos[1] = self.allegro_jstates[5]
            self.mid_qpos[2] = self.allegro_jstates[6]
            self.mid_qpos[3] = self.allegro_jstates[7]
            self.ring_qpos[0] = self.allegro_jstates[8]
            self.ring_qpos[1] = self.allegro_jstates[9]
            self.ring_qpos[2] = self.allegro_jstates[10]
            self.ring_qpos[3] = self.allegro_jstates[11]
            self.thumb_qpos[0] = self.allegro_jstates[12]
            self.thumb_qpos[1] = self.allegro_jstates[13]
            self.thumb_qpos[2] = self.allegro_jstates[14]
            self.thumb_qpos[3] = self.allegro_jstates[15]
            for iq in range(4):
                # index
                self.index_weights[iq,0] = 13.44 - 12.0*(self.index_qpos[iq]-self.index_limits[1,iq])*(self.index_limits[0,iq]-self.index_qpos[iq])/self.index_ranges_sq[0,iq]
                # mid
                self.mid_weights[iq,0] = 13.44 - 12.0*(self.mid_qpos[iq]-self.mid_limits[1,iq])*(self.mid_limits[0,iq]-self.mid_qpos[iq])/self.mid_ranges_sq[0,iq]
                # ring
                self.ring_weights[iq,0] = 13.44 - 12.0*(self.ring_qpos[iq]-self.ring_limits[1,iq])*(self.ring_limits[0,iq]-self.ring_qpos[iq])/self.ring_ranges_sq[0,iq]
                # thumb
                self.thumb_weights[iq,0] = 13.44 - 12.0*(self.thumb_qpos[iq]-self.thumb_limits[1,iq])*(self.thumb_limits[0,iq]-self.thumb_qpos[iq])/self.thumb_ranges_sq[0,iq]


                # if self.mid_limits[0,iq] - self.mid_qpos[0] < 0.05:
                #     self.mid_if_saturated[iq,0] = True
                # elif self.mid_qpos[0] - self.mid_limits[1,iq] < 0.05:
                #     self.mid_if_saturated[iq,0] = True
                # else:
                #     self.mid_if_saturated[iq,0] = False
                # # ring
                # if self.ring_limits[0,iq] - self.ring_qpos[0] < 0.05:
                #     self.ring_if_saturated[iq,0] = True
                # elif self.ring_qpos[0] - self.ring_limits[1,iq] < 0.05:
                #     self.ring_if_saturated[iq,0] = True
                # else:
                #     self.ring_if_saturated[iq,0] = False
                # # thumb
                # if self.thumb_limits[0,iq] - self.thumb_qpos[0] < 0.05:
                #     self.thumb_if_saturated[iq,0] = True
                # elif self.thumb_qpos[0] - self.thumb_limits[1,iq] < 0.05:
                #     self.thumb_if_saturated[iq,0] = True
                # else:
                #     self.thumb_if_saturated[iq,0] = False
            # self.allegro_jstates[1] = msg.position[1]
            # self.allegro_jstates[2] = msg.position[2]
            # self.allegro_jstates[3] = msg.position[3]
            # self.allegro_jstates[4] = msg.position[4]
            # self.allegro_jstates[5] = msg.position[5]
            # self.allegro_jstates[6] = msg.position[6]
            # self.allegro_jstates[7] = msg.position[7]
            # self.allegro_jstates[8] = msg.position[8]allegro_jstates
            # self.allegro_jstates[11] = msg.position[11]
            # self.allegro_jstates[12] = msg.position[12]
            # self.allegro_jstates[13] = msg.position[13]
            # self.allegro_jstates[14] = msg.position[14]
            # self.allegro_jstates[15] = msg.position[15]
        if msg.header != None:
            if msg.header.seq != None:
                self.jstate_seq = msg.header.seq
            if msg.header.stamp != None:
                if msg.header.stamp.secs != None:
                    self.jstate_secs = msg.header.stamp.secs
                else:
                    self.jstate_secs = 0
                if msg.header.stamp.nsecs != None:
                    self.jstate_nsecs = msg.header.stamp.nsecs
                else:
                    self.jstate_nsecs = 0

    def allegro_tacstates_callback(self, msg):
        self.index_tip = np.array(msg.index_tip_Value)
        self.mid_tip = np.array(msg.middle_tip_Value)
        self.ring_tip = np.array(msg.ring_tip_Value)
        self.thumb_tip = np.array(msg.thumb_tip_Value)
        # Call main_process in the lowest-frequency callback function

    def ur_eestates_callback(self, msg):
        self.ur_eestates[0] = msg.pose.position.x
        self.ur_eestates[1] = msg.pose.position.y
        self.ur_eestates[2] = msg.pose.position.z
        self.ur_eestates[3] = msg.pose.orientation.x
        self.ur_eestates[4] = msg.pose.orientation.y
        self.ur_eestates[5] = msg.pose.orientation.z
        self.ur_eestates[6] = msg.pose.orientation.w
        if msg.header != None:
            if msg.header.seq != None:
                self.eestate_seq = msg.header.seq
            if msg.header.stamp != None:
                if msg.header.stamp.secs != None:
                    self.eestate_secs = msg.header.stamp.secs
                else:
                    self.eestate_secs = 0
                if msg.header.stamp.nsecs != None:
                    self.eestate_nsecs = msg.header.stamp.nsecs
                else:
                    self.eestate_nsecs = 0

    def loop(self):
        rospy.logwarn("Starting MySbuscriber Loop...")
        rospy.spin()

    # Some functions that simplify the main_process() below
    def write_publish_ee_cmd(self, pos_t, quat_t):
        self.urcmd_pub.pose = pose_quat2new_ros_pose(np.hstack((pos_t, quat_t)))
        self.publish_ee_cmd()

    def write_publish_allegro_cmd(self, jcmd):
        self.jcmd_pub.position = jcmd
        self.publish_allegro_cmd()

    def publish_ee_cmd(self):
        """
        Publish self.urcmd_pub
        In this function, you only need to specify urcmd_pub.pose,\n
        urcmd_pub.header is auto filled, and then urcmd_pub is published.\n
        If cmd is too large, it will be reset to current ee_state.
        """
        # next position cannot be too far from the initial position when the procedure began
        if np.linalg.norm(self.init_ur_eestates[:3]-ros_pose2new_pose_quat(self.urcmd_pub.pose)[:3]) < 0.9:
            # next position cannot be too far from last position
            if np.linalg.norm(self.ur_eestates[:3]-ros_pose2new_pose_quat(self.urcmd_pub.pose)[:3]) < 0.15:
                self.urcmd_pub.header.seq = self.urcmd_pub.header.seq + 1
                self.urcmd_pub.header.stamp = rospy.Time.now()
                self.ur_publisher.publish(self.urcmd_pub)
            else:
                self.urcmd_pub.pose = pose_quat2new_ros_pose(self.ur_eestates)
                print("Control signal too far from current position, not pulishing")
        else:
            self.urcmd_pub.pose = pose_quat2new_ros_pose(self.ur_eestates)
            print("Control signal too far from initial position, not pulishing")

    def publish_allegro_cmd(self):
        """
        In this function, you only need to specify jcmd_pub.position,\n
        jcmd_pub.header is auto filled, and then jcmd_pub is published.\n
        Joint limit is applied, cmd values too large will be set back to limits.
        """
        self.jcmd_pub.header.seq = self.jcmd_pub.header.seq + 1
        self.jcmd_pub.header.stamp = rospy.Time.now()
        jcmd = np.array(self.jcmd_pub.position)
        # -0.47 0.47
        for i_joint in range(16):
            # self.j_limits is a matrix saving the joint limits of the Allegro Hand:
            # self.j_limits[0,:] saves the upper limits, self.j_limits[1,:] saves the lower limits
            # e.g., self.j_limits[0,15] saves the upper limit of the 16th joint (tip joint of the thumb)
            if jcmd[i_joint] < self.j_limits[1,i_joint]:
                jcmd[i_joint] = self.j_limits[1,i_joint]
            elif jcmd[i_joint] > self.j_limits[0,i_joint]:
                jcmd[i_joint] = self.j_limits[0,i_joint]
        self.jcmd_pub.position = jcmd
        self.allegro_publisher.publish(self.jcmd_pub)

    def plan_grasp(self,obj_pos=np.array([0, 0, 0.785]),obj_euler=np.array([0, 0, 1.57]),hand_pos=np.array([0, -0.4, 0.85]),obj_in_hand_pos=np.array([0.09, -0.16, -0.0]), obj_in_hand_euler=np.array([-1.57, 0, 0])):
        """
        Plan a grasp here (just planning, not moving):\n
        object pose:\n
        obj_pos = np.array([0, 0, 0.785])\n
        obj_euler = np.array([0, 0, 1.57])
        """
        obj_dcm = Rotation.from_euler("xyz",obj_euler).as_dcm()
        # initial hand pose, orientation is not important:
        # hand_pos = np.array([0, -0.4, 0.85])
        hand2obj = obj_pos - hand_pos # Make this vector close to obj's x-axis
        obj_y_specified = np.cross(obj_dcm[:3,2].flatten(),hand2obj)
        obj_y_specified = obj_y_specified/np.linalg.norm(obj_y_specified)
        obj_x_specified = np.cross(obj_y_specified, obj_dcm[:3,2].flatten())
        obj_x_specified = obj_x_specified/np.linalg.norm(obj_x_specified)
        obj_dcm[:3,0] = obj_x_specified
        obj_dcm[:3,1] = obj_y_specified
        obj_T = np.eye(4)
        obj_T[:3,:3] = obj_dcm
        obj_T[:3,3] = obj_pos
        obj_in_hand_T = np.eye(4)
        obj_in_hand_T[:3,3] = obj_in_hand_pos
        obj_in_hand_T[:3,:3] = Rotation.from_euler("xyz",obj_in_hand_euler).as_dcm()
        hand_pregrasp_T = np.dot(obj_T, np.linalg.inv(obj_in_hand_T))
        # pregrasping hand pose:
        hand_pregrasp_pos = hand_pregrasp_T[:3,3].flatten()
        hand_pregrasp_quat = Rotation.from_dcm(hand_pregrasp_T[:3,:3]).as_quat()
        return hand_pregrasp_pos, hand_pregrasp_quat

    def move2posquat(self, pos, quat, vel=0.01, angle_vel_degrees=3.0, error_p=0.01, error_angle_degrees=3.0):
        """
        error_p is the tolerance of position errors (default = 0.01),
        error_angle_degrees is the tolerance of orientation errors (in degrees) (default = 3.0),
        """
        self.get_time()
        p_distance = pos - self.ur_eestates[:3]
        duration_p = np.linalg.norm(p_distance)/vel
        v = p_distance/duration_p
        duration_o = quats2delta_angle_degrees(quat, self.ur_eestates[3:])/angle_vel_degrees
        w = angular_vel_from_quats(quat,self.ur_eestates[3:],dt=duration_o)
        while not rospy.is_shutdown():
            self.get_time()
            pos_t = ros_pose2new_pose_quat(self.urcmd_pub.pose)[:3]
            quat_t = ros_pose2new_pose_quat(self.urcmd_pub.pose)[3:]
            I3d = np.eye(3)
            delta_pos = np.linalg.norm(pos-self.ur_eestates[:3])
            delta_angle_d = quats2delta_angle_degrees(quat, self.ur_eestates[3:])
            if delta_pos > error_p:
                pos_t = self.delta_time*v + ros_pose2new_pose_quat(self.urcmd_pub.pose)[:3] # Use real current pos or current cmd pos?
            if delta_angle_d > error_angle_degrees:
                R_0 = Rotation.from_quat(ros_pose2new_pose_quat(self.urcmd_pub.pose)[3:]).as_dcm()
                R_t = np.dot((self.delta_time*cross_product_matrix_from_vector3d(w)+I3d), R_0)
                quat_t = Rotation.from_dcm(R_t).as_quat()
            if (delta_pos < error_p) and (delta_angle_d < error_angle_degrees):
                print("Palm stop approaching: distance between target pose and current pose is below tolerance.")
                break
            self.write_publish_ee_cmd(pos_t, quat_t)
            rospy.sleep(0.001)
            self.save_time()

#######################################################################################################################
    def main_process(self):
        # self.save_time()
        
        t_0 = 0.0
        t_t = 0.0
        while not rospy.is_shutdown():
            if t_t - t_0 < 1.0:
                self.get_time()
                t_t = t_t + self.delta_time
                # with self.mutex:
                jcmd = np.array([0.0235, 0.544, 0.749, 0.989,
                                    0, 0.0, 0.0, 0.0,
                                    0.0, 0.0, 0.0, 0.0,
                                    1.55, 0.187, 0.297, 0.606])
                self.jcmd_pub.position = jcmd
                self.publish_allegro_cmd()

                rospy.sleep(0.004)
                # print("delta_time:", self.delta_time, "current_time:", self.current_time, "last_time:", self.last_time)
                self.save_time()
            else:
                break
        print("Middle and thumb finger tips stop.")

        print("IK test begins ...")
        target_pose = np.mat([0.0235, 0.544, 0.749, 0.989,
                                0, 0.544, 0.73, 0.989,
                                -0.24, 0.544, 0.749, 0.881,
                                1.2, 0.187, 0.297, 0.606]).T
        print("Hand joints target pose:\n", target_pose)
        thumb_tf = np.mat(np.zeros((3,1)))
        thumb_tf_d = np.mat([300, 0, 8.5e-4]).T
        mid_tf = np.mat(np.zeros((3,1)))
        mid_tf_d = np.mat([300, 0, 8.5e-4]).T
        print("Desired tactile features:")
        print("Thumb tip:\n", thumb_tf_d)
        print("Mid tip:\n", mid_tf_d)
        # tactile_jacobian
        # feature = [force, y, z]
        # J_s_+ = np.mat([[-3e-6,  0,  0],
        #                 [ 0, -0.4,  0],
        #                 [ 0,  0, -0.75],
        #                 [ 0,  0,  0],
        #                 [ 0,  0,  25],
        #                 [ 0, -60,  0]])

        # J_s * V_tip = V_tf
        # twist of tip ----> rate of tactile feature
        # Version 1:
        I_14 = np.mat(np.eye(14))
        J = np.mat(np.zeros((12,14)))
        J_palm2index = np.mat(np.eye(6))
        J_palm2mid = np.mat(np.eye(6))
        J_palm2ring = np.mat(np.eye(6))
        J_palm2thumb = np.mat(np.eye(6))
        D = np.mat(np.zeros((12,14)))
        D_pinv = np.mat(np.zeros((14,12)))
        delta_u_d = np.mat(np.zeros((14,1)))
        index_in_palm_T = np.mat(np.eye(4))
        mid_in_palm_T = np.mat(np.eye(4))
        ring_in_palm_T = np.mat(np.eye(4))
        thumb_in_palm_T = np.mat(np.eye(4))
        M = np.mat(np.zeros((3,3)))
        p = np.mat(np.zeros((3,1)))
        p_thumb2index_d = np.mat([0.006, 0.01, 0.1]).T
        p_obj = np.mat([0,0,1.5]).T
        quat_obj = np.array([0,0,0,1])
        p_index_in_obj = np.mat([0,0.047,0]).T
        euler_index_in_obj = np.array([90,0,-90])
        p_thumb_in_obj = np.mat([0,-0.05,0]).T
        euler_thumb_in_obj = np.array([-90,0,90])
        T_obj = np.mat(np.eye(4))
        T_obj[:3,:3] = Rotation.from_quat(quat_obj).as_dcm()
        T_obj[:3,3] = p_obj
        # p_index = np.matmul(T_obj[:3,:3], p_index_in_obj) + p_obj
        # R_index = np.matmul(T_obj[:3,:3], Rotation.from_euler("xyz",euler_index_in_obj,degrees=True).as_dcm())
        # p_thumb = np.matmul(T_obj[:3,:3], p_thumb_in_obj) + p_obj
        # R_thumb = np.matmul(T_obj[:3,:3], Rotation.from_euler("xyz",euler_thumb_in_obj,degrees=True).as_dcm())
        T_palm_d = pose2T(np.reshape(copy.deepcopy(self.ur_eestates),(7,1)))
        T_palm_d0 = copy.deepcopy(T_palm_d)
        index_in_palm_T_d = np.mat(np.eye(4))
        thumb_in_palm_T_d = np.mat(np.eye(4))
        p_index = np.mat([0.1908187,  0.30554848, 0.74719301]).T
        p_index_0 = copy.deepcopy(p_index)
        R_index = np.mat(Rotation.from_quat([-0.29331383,  0.73101278,  0.5181307,  -0.33335849]).as_dcm())
        R_index_0 = copy.deepcopy(R_index)
        p_thumb = np.mat([0.12770555, 0.30455613, 0.78832995]).T
        p_thumb_0 = copy.deepcopy(p_thumb)
        R_thumb = np.mat(Rotation.from_quat([-0.41792986,  0.46522238, -0.38143159,  0.68074424]).as_dcm())
        R_thumb_0 = copy.deepcopy(R_thumb)
        self.index_goal_pub.pose = pose_quat2new_ros_pose([0.1708187,  0.30554848, 0.74719301,  -0.29331383,  0.73101278,  0.5181307,  -0.33335849])
        self.thumb_goal_pub.pose = pose_quat2new_ros_pose([0.14770555, 0.30455613, 0.78832995,  -0.41792986,  0.46522238, -0.38143159,  0.68074424])
        t_0 = t_t = 0.0
        while not rospy.is_shutdown():
            if t_t - t_0 < 3.0:
                self.get_time()
                t_t = t_t + self.delta_time
                self.index_goal_publisher.publish(self.index_goal_pub)
                self.thumb_goal_publisher.publish(self.thumb_goal_pub)
                # with self.mutex:

                rospy.sleep(0.004)
                # print("delta_time:", self.delta_time, "current_time:", self.current_time, "last_time:", self.last_time)
                self.save_time()
            else:
                # a_key = input("The first goal poses are shown in the simulator...\nInput a number to continue...")
                break

        T_palm = np.mat(np.eye(4))
        w_index = np.mat(np.zeros((3,1)))
        w_thumb = np.mat(np.zeros((3,1)))
        twist = np.mat(np.zeros((12,1)))
        AdT_ground2palmX2 = np.mat(np.eye(12))
        AdT_palmX2 = np.mat(np.eye(12))
        # Read target poses
        target_pose_from_txt = np.mat(np.loadtxt(self.this_file_dir+"/poseRecord.txt"))
        sample_size = np.size(target_pose_from_txt,0)/2
        i_sample = -1
        t0_sin = self.current_time
        current_time_list = []
        px_index_list = []
        thetax_index_list = []
        thetaz_index_list = []
        thetax_thumb_list = []
        thetaz_thumb_list = []
        py_index_list = []
        pz_index_list = []
        pxd_index_list = []
        pyd_index_list = []
        pzd_index_list = []
        px_thumb_list = []
        py_thumb_list = []
        pz_thumb_list = []
        pxd_thumb_list = []
        pyd_thumb_list = []
        pzd_thumb_list = []
        while not rospy.is_shutdown():
            ## Calc
            # Timing
            self.get_time()
            # get last cmds
            jcmd = np.array(self.jcmd_pub.position)
            ee_cmd = ros_pose2new_pose_quat(self.urcmd_pub.pose)
            # get last states
            jstate = np.mat(copy.deepcopy(self.allegro_jstates)).reshape((16,1))
            ee_state = np.mat(copy.deepcopy(self.ur_eestates)).reshape(7,1)
            T_palm = pose2T(ee_state)
            
            T_palm_d[1,3] = T_palm_d0[1,3] + 0.2*math.sin(0.08*(self.current_time - t0_sin))
            # forward kinematics
            # Calculate desired index pose
            # index
            self.index_qpos_d[0] = self.index_limits[1,0] + 0.35*(self.index_limits[0,0] - self.index_limits[1,0])
            self.index_qpos_d[1] = self.index_limits[1,1] + (0.5 + 0.5*math.sin(0.2*(self.current_time - t0_sin)))*(self.index_limits[0,1] - self.index_limits[1,1])
            self.index_qpos_d[2] = self.index_limits[1,2] + 0.35*(self.index_limits[0,2] - self.index_limits[1,2])
            # print("self.index_qpos_d[1]:", self.index_qpos_d[1])
            self.index_qpos_d[3] = self.index_limits[1,3] + (0.35 + 0.35*math.sin(0.2*(self.current_time - t0_sin)))*(self.index_limits[0,3] - self.index_limits[1,3])
            kdl_calc_fk(self.index_fk, self.index_qpos_d, self.index_pos)
            M[0,0] = copy.deepcopy(self.index_pos.M[0,0])
            M[0,1] = copy.deepcopy(self.index_pos.M[0,1])
            M[0,2] = copy.deepcopy(self.index_pos.M[0,2])
            M[1,0] = copy.deepcopy(self.index_pos.M[1,0])
            M[1,1] = copy.deepcopy(self.index_pos.M[1,1])
            M[1,2] = copy.deepcopy(self.index_pos.M[1,2])
            M[2,0] = copy.deepcopy(self.index_pos.M[2,0])
            M[2,1] = copy.deepcopy(self.index_pos.M[2,1])
            M[2,2] = copy.deepcopy(self.index_pos.M[2,2])
            p[0,0] = copy.deepcopy(self.index_pos.p[0])
            p[1,0] = copy.deepcopy(self.index_pos.p[1])
            p[2,0] = copy.deepcopy(self.index_pos.p[2])
            index_in_palm_T_d[:3,:3] = M
            index_in_palm_T_d[:3,3] = p
            # print("index_in_palm_T_d:\n", index_in_palm_T_d)
            index_T_d = np.matmul(T_palm_d, index_in_palm_T_d)
            # print("T_palm_d:\n",T_palm_d)
            p_index = index_T_d[:3,3]
            R_index = index_T_d[:3,:3]
            # thumb
            self.thumb_qpos_d[0] = self.thumb_limits[1,0] + 0.25*(self.thumb_limits[0,0] - self.thumb_limits[1,0])
            # self.thumb_qpos_d[1] = self.thumb_limits[1,1] + 0.5*(self.thumb_limits[0,1] - self.thumb_limits[1,1])
            self.thumb_qpos_d[2] = self.thumb_limits[1,2] + (0.5 + 0.5*math.sin(0.2*(self.current_time - t0_sin)))*(self.thumb_limits[0,2] - self.thumb_limits[1,2])
            self.thumb_qpos_d[3] = self.thumb_limits[1,3] + (0.35 + 0.35*math.sin(0.2*(self.current_time - t0_sin)))*(self.thumb_limits[0,3] - self.thumb_limits[1,3])
            kdl_calc_fk(self.thumb_fk, self.thumb_qpos_d, self.thumb_pos)
            M[0,0] = copy.deepcopy(self.thumb_pos.M[0,0])
            M[0,1] = copy.deepcopy(self.thumb_pos.M[0,1])
            M[0,2] = copy.deepcopy(self.thumb_pos.M[0,2])
            M[1,0] = copy.deepcopy(self.thumb_pos.M[1,0])
            M[1,1] = copy.deepcopy(self.thumb_pos.M[1,1])
            M[1,2] = copy.deepcopy(self.thumb_pos.M[1,2])
            M[2,0] = copy.deepcopy(self.thumb_pos.M[2,0])
            M[2,1] = copy.deepcopy(self.thumb_pos.M[2,1])
            M[2,2] = copy.deepcopy(self.thumb_pos.M[2,2])
            p[0,0] = copy.deepcopy(self.thumb_pos.p[0])
            p[1,0] = copy.deepcopy(self.thumb_pos.p[1])
            p[2,0] = copy.deepcopy(self.thumb_pos.p[2])
            thumb_in_palm_T_d[:3,:3] = M
            thumb_in_palm_T_d[:3,3] = p
            thumb_T_d = np.matmul(T_palm_d, thumb_in_palm_T_d)
            p_thumb = thumb_T_d[:3,3]
            R_thumb = thumb_T_d[:3,:3]



            kdl_calc_fk(self.index_fk, self.index_qpos, self.index_pos)
            M[0,0] = copy.deepcopy(self.index_pos.M[0,0])
            M[0,1] = copy.deepcopy(self.index_pos.M[0,1])
            M[0,2] = copy.deepcopy(self.index_pos.M[0,2])
            M[1,0] = copy.deepcopy(self.index_pos.M[1,0])
            M[1,1] = copy.deepcopy(self.index_pos.M[1,1])
            M[1,2] = copy.deepcopy(self.index_pos.M[1,2])
            M[2,0] = copy.deepcopy(self.index_pos.M[2,0])
            M[2,1] = copy.deepcopy(self.index_pos.M[2,1])
            M[2,2] = copy.deepcopy(self.index_pos.M[2,2])
            p[0,0] = copy.deepcopy(self.index_pos.p[0])
            p[1,0] = copy.deepcopy(self.index_pos.p[1])
            p[2,0] = copy.deepcopy(self.index_pos.p[2])
            index_in_palm_T[:3,:3] = M
            index_in_palm_T[:3,3] = p
            J_palm2index[0:3,3:6] = -cross_product_matrix_from_vector3d(index_in_palm_T[:3,3])

            kdl_calc_fk(self.mid_fk, self.mid_qpos, self.mid_pos)
            M[0,0] = copy.deepcopy(self.mid_pos.M[0,0])
            M[0,1] = copy.deepcopy(self.mid_pos.M[0,1])
            M[0,2] = copy.deepcopy(self.mid_pos.M[0,2])
            M[1,0] = copy.deepcopy(self.mid_pos.M[1,0])
            M[1,1] = copy.deepcopy(self.mid_pos.M[1,1])
            M[1,2] = copy.deepcopy(self.mid_pos.M[1,2])
            M[2,0] = copy.deepcopy(self.mid_pos.M[2,0])
            M[2,1] = copy.deepcopy(self.mid_pos.M[2,1])
            M[2,2] = copy.deepcopy(self.mid_pos.M[2,2])
            p[0,0] = copy.deepcopy(self.mid_pos.p[0])
            p[1,0] = copy.deepcopy(self.mid_pos.p[1])
            p[2,0] = copy.deepcopy(self.mid_pos.p[2])
            mid_in_palm_T[:3,:3] = M
            mid_in_palm_T[:3,3] = p
            J_palm2mid[0:3,3:6] = -cross_product_matrix_from_vector3d(mid_in_palm_T[:3,3])

            kdl_calc_fk(self.ring_fk, self.ring_qpos, self.ring_pos)
            M[0,0] = copy.deepcopy(self.ring_pos.M[0,0])
            M[0,1] = copy.deepcopy(self.ring_pos.M[0,1])
            M[0,2] = copy.deepcopy(self.ring_pos.M[0,2])
            M[1,0] = copy.deepcopy(self.ring_pos.M[1,0])
            M[1,1] = copy.deepcopy(self.ring_pos.M[1,1])
            M[1,2] = copy.deepcopy(self.ring_pos.M[1,2])
            M[2,0] = copy.deepcopy(self.ring_pos.M[2,0])
            M[2,1] = copy.deepcopy(self.ring_pos.M[2,1])
            M[2,2] = copy.deepcopy(self.ring_pos.M[2,2])
            p[0,0] = copy.deepcopy(self.ring_pos.p[0])
            p[1,0] = copy.deepcopy(self.ring_pos.p[1])
            p[2,0] = copy.deepcopy(self.ring_pos.p[2])
            ring_in_palm_T[:3,:3] = M
            ring_in_palm_T[:3,3] = p
            J_palm2ring[0:3,3:6] = -cross_product_matrix_from_vector3d(ring_in_palm_T[:3,3])

            # print("mid_in_palm_T:\n", mid_in_palm_T)
            kdl_calc_fk(self.thumb_fk, self.thumb_qpos, self.thumb_pos)
            M[0,0] = self.thumb_pos.M[0,0]
            M[0,1] = self.thumb_pos.M[0,1]
            M[0,2] = self.thumb_pos.M[0,2]
            M[1,0] = self.thumb_pos.M[1,0]
            M[1,1] = self.thumb_pos.M[1,1]
            M[1,2] = self.thumb_pos.M[1,2]
            M[2,0] = self.thumb_pos.M[2,0]
            M[2,1] = self.thumb_pos.M[2,1]
            M[2,2] = self.thumb_pos.M[2,2]
            p[0,0] = self.thumb_pos.p[0]
            p[1,0] = self.thumb_pos.p[1]
            p[2,0] = self.thumb_pos.p[2]
            thumb_in_palm_T[:3,:3] = M
            thumb_in_palm_T[:3,3] = p
            J_palm2thumb[0:3,3:6] = -cross_product_matrix_from_vector3d(thumb_in_palm_T[:3,3])


            # finger Jacobian
            
            # index_jac = self.index_kdl_kin.jacobian(jstate[0:4])

            """ Hand to finger tips Jacobians: """
            J_index = copy.deepcopy(self.index_kdl_kin.jacobian(jstate[0:4]))
            J_index = np.mat(J_index)
            J_mid = copy.deepcopy(self.mid_kdl_kin.jacobian(jstate[4:8]))
            J_mid = np.mat(J_mid)
            J_ring = copy.deepcopy(self.ring_kdl_kin.jacobian(jstate[8:12]))
            J_ring = np.mat(J_ring)
            J_thumb = copy.deepcopy(self.thumb_kdl_kin.jacobian(jstate[12:16]))
            J_thumb = np.mat(J_thumb)
            """ Deal with saturations """
            # for i_ifs in range(4):
            #     if self.index_if_saturated[i_ifs,0]:
            #         J_index[:,i_ifs] = J_index[:,i_ifs]/30.0
            #     if self.thumb_if_saturated[i_ifs,0]:
            #         J_thumb[:,i_ifs] = J_thumb[:,i_ifs]/30.0



            # Total Jacobian from all control variable to 2 tips:
            w_diag = np.reshape(np.array(np.vstack((np.vstack((np.ones((6,1)),self.index_weights)), self.thumb_weights))), 14)
            
            J[0:6,0:6] = J_palm2index
            J[0:6,6:10] = J_index
            J[6:12,0:6] = J_palm2thumb
            J[6:12,10:14] = J_thumb
            
            # p_index[0] = p_index_0[0] + 0.01*math.sin(0.8*(self.current_time - t0_sin))
            # p_index[1] = p_index_0[1] + 0.05*math.sin(0.4*(self.current_time - t0_sin))
            # rz_angle = 
            # R_rotation = Rotation.from_euler("xyz",[0.0, 0.0, 0.3*math.sin(0.8*(self.current_time - t0_sin))]).as_dcm()
            # R_index = np.matmul(R_index_0, R_rotation)
            # R_index = np.matmul(R_rotation.T, R_index_0)
            # R_thumb = np.matmul(R_thumb_0, R_rotation.T)
            # R_thumb = np.matmul(R_rotation, R_thumb_0)
            # p_thumb[0] = p_thumb_0[0] - 0.01*math.sin(0.8*(self.current_time - t0_sin))
            # p_thumb[1] = p_thumb_0[1] + 0.05*math.sin(0.4*(self.current_time - t0_sin))
            # p_thumb[2] = p_thumb_0[2] + abs(0.02*math.sin(0.4*(self.current_time - t0_sin)))
            p_index_current = np.matmul(T_palm, index_in_palm_T)[:3,3]
            delta_p_index = p_index - p_index_current
            p_thumb_current = np.matmul(T_palm, thumb_in_palm_T)[:3,3]
            delta_p_thumb = p_thumb - p_thumb_current
            
            R_index_current = np.matmul(T_palm[:3,:3], index_in_palm_T[:3,:3])
            delta_angle_index = R2delta_angle(R_index, R_index_current)
            R_thumb_current = np.matmul(T_palm[:3,:3], thumb_in_palm_T[:3,:3])
            delta_angle_thumb = R2delta_angle(R_thumb, R_thumb_current)
            T_index_target = np.mat(np.eye(4))
            T_thumb_target = np.mat(np.eye(4))
            T_index_target[:3,:3] = R_index
            T_index_target[:3,3] = p_index
            T_thumb_target[:3,:3] = R_thumb
            T_thumb_target[:3,3] = p_thumb
            pose_index_target = T2pose(T_index_target)
            pose_thumb_target = T2pose(T_thumb_target)
            self.index_goal_pub.pose = pose_quat2new_ros_pose(pose_index_target)
            self.thumb_goal_pub.pose = pose_quat2new_ros_pose(pose_thumb_target)
            self.index_goal_publisher.publish(self.index_goal_pub)
            self.thumb_goal_publisher.publish(self.thumb_goal_pub)
            # delta_sum = np.linalg.norm(delta_p_index+delta_p_thumb)
            # if delta_sum < -0.001:
            #     palm_p_weight = 0.05
            # elif delta_sum > 0.001:
            #     palm_p_weight = 0.05
            # else:
            #     palm_p_weight = 1.0 - 950.0*delta_sum

            # w_diag[0] = w_diag[1] = w_diag[2] = w_diag[3] = w_diag[4] = w_diag[5] = 0.9
            # print("Weight: ", w_diag)
            w_diag_inv_sqr = np.sqrt(1/w_diag)
            W_inv_sqr = np.diag(w_diag_inv_sqr)
            J = np.matmul(J, W_inv_sqr) # weighted Jacobian
            # print("J:\n", J)
            
            
            # if (np.linalg.norm(delta_p_index) > 0.001) or (np.linalg.norm(delta_p_thumb) > 0.001) or (delta_angle_index > 0.1) or (delta_angle_thumb > 0.1):
            AdTpalm = T2AdT(T_palm)
            AdT_palmX2[0:6,0:6] = AdTpalm
            AdT_palmX2[6:12,6:12] = AdTpalm
            AdT_ground2palm = T2AdT(np.linalg.inv(T_palm))
            AdT_ground2palmX2[0:6,0:6] = AdT_ground2palm
            AdT_ground2palmX2[6:12,6:12] = AdT_ground2palm
            # print("\np_index (index goal position):", p_index.T)
            # print("p_index_current (index current position):", p_index_current.T)
            # print("delta_p_index (index position error):", delta_p_index.T)
            # print("\np_thumb (thumb goal position):", p_thumb.T)
            # print("p_thumb_current (thumb current position):", p_thumb_current.T)
            # print("delta_p_thumb (thumb position error):", delta_p_thumb.T)
            # print("Desired index R:\n", R_index)
            # print("Current index R:\n", R_index_current)
            # print("delta_angle_index (index orientation error (rads)):", delta_angle_index)
            # print("Desired thumb R:\n", R_thumb)
            # print("Current thumb R:\n", R_thumb_current)
            # print("delta_angle_thumb (thumb orientation error (rads)):", delta_angle_thumb)
            _k = 4.5
            v_index = _k*delta_p_index
            v_thumb = _k*delta_p_thumb
            w_index[0,0], w_index[1,0], w_index[2,0] = angular_vel_from_quats(Rotation.from_dcm(R_index).as_quat(), Rotation.from_dcm(R_index_current).as_quat(), dt=0.125)
            w_thumb[0,0], w_thumb[1,0], w_thumb[2,0] = angular_vel_from_quats(Rotation.from_dcm(R_thumb).as_quat(), Rotation.from_dcm(R_thumb_current).as_quat(), dt=0.125)
            twist[0:3,0] = v_index
            twist[3:6,0] = w_index
            twist[6:9,0] = v_thumb
            twist[9:12,0] = w_thumb
            # print("\nGoal twist:", twist.T)
            twist = np.matmul(AdT_ground2palmX2, twist)
            """
            My special IK:
            (1) q_vel = alpha*J^T*e + beta*(I_14x14 - J_pinv*J)*(q^* - q)
            alpha = 
            (2) q_vel = J_pinv*e + beta*(I_14x14 - J_pinv*J)*(q^* - q)
            How to get J_pinv?
                1) singular value decomposition of J: J = U * D * V^T
                2) Let D_pinv be the M-P-pseudoinverse of D, then the entries of D_pinv are:
                    d_pinv_ii = 1/d_ii (if d_ii != 0) or 0 (if d_ii == 0)
                3) then, J_pinv = V * D_pinv * U^T
            """
            e = twist
            e_T = e.T
            J_T = J.T
            JJ_T = np.matmul(J, J_T)
            U, sinValues, V_T = np.linalg.svd(J, full_matrices=True, compute_uv=True)
            # print("DoF provited by J:", np.size(sinValues), "Minimum singular value:", min(sinValues))
            # D_part = np.mat(np.diag(sinValues))
            # print("D_pinv:\n",D_pinv)
            D_pinv = np.mat(np.zeros_like(D_pinv))
            for i_sing in range(np.size(sinValues)):
                D_pinv[i_sing,i_sing] = 1.0/sinValues[i_sing]
            V = np.mat(V_T).T
            U_T = np.mat(U).T
            J_pinv = np.matmul(np.matmul(V, D_pinv), U_T)
            J_null = I_14 - np.matmul(J_pinv, J) # column_null_space of J
            # alpha = 7.0*np.matmul(e_T, np.matmul(JJ_T, e))/np.matmul(np.matmul(JJ_T, e).T, np.matmul(JJ_T, e)) # (1)
            alpha = np.mat([[1.0]]) # (2)
            beta = 0.19*self.delta_time
            # delta_u_d[0,0] = -0.02
            # delta_u_d[2,0] = 0.02
            # delta_u_d[4,0] = 0.06
            delta_u_d[6:10,0] = target_pose[0:4,0] - jstate[0:4,0]
            delta_u_d[10:14,0] = target_pose[12:16,0] - jstate[12:16,0]
            # delta_u = np.dot(alpha[0,0], np.matmul(J_T, e)) + np.dot(beta, np.matmul(J_null, delta_u_d)) # (1)
            delta_u = np.dot(alpha[0,0], np.matmul(J_pinv, self.delta_time*twist)) + np.dot(beta, np.matmul(J_null, delta_u_d))
            # print("Control signal:", delta_u.T)
            # print("Index joint states:", jstate[0:4,0].T)
            # print("Thumb joint states:", jstate[12:16,0].T)
            delta_u = np.matmul(W_inv_sqr, delta_u)
            delta_q = np.mat(np.zeros((16,1)))
            delta_q[0:4,0] = delta_u[6:10,0]
            # delta_q[0:4,0] = delta_q[0:4,0] + self.delta_time*delta_u_d[6:10,0]*0.01
            delta_q[12:16,0] = delta_u[10:14,0]
            # delta_q[12:16,0] = delta_q[12:16,0] + self.delta_time*delta_u_d[10:14,0]*0.01
            delta_q = np.array(delta_q).T.flatten()
            jcmd = jcmd + delta_q
            self.write_publish_allegro_cmd(jcmd)
            # print("Output twist*dt predicted by Jacobian (J):", np.matmul(AdT_palmX2, np.matmul(J, delta_u)).T)
            
            palm_d_pose_in_world = np.matmul(AdTpalm, delta_u[0:6,0])
            pose_palm_t = delta_pose2next_pose(palm_d_pose_in_world, ee_cmd)
            # print("palm_d_pose_in_world (control signal):", palm_d_pose_in_world.T)
            # print("D_non-zero-part:\n", np.diag(sinValues), "\n")
            self.write_publish_ee_cmd(pose_palm_t[:3], pose_palm_t[3:])
            
            if self.current_time - t0_sin > 60.0:
                class SnaptoCursor(object):
                    def __init__(self, ax, x, y, y2):
                        self.ax = ax
                        self.ly = ax.axvline(color='k', alpha=0.2)  # the vert line
                        self.marker, = ax.plot([0],[0], marker="o", color="crimson", zorder=3) 
                        self.x = x
                        self.y = y
                        self.y2 = y2
                        self.absy = abs(y-y2)
                        self.txt = ax.text(0.7, 0.9, '')

                    def mouse_move(self, event):
                        if not event.inaxes: return
                        x, y = event.xdata, event.ydata
                        indx = np.searchsorted(self.x, [x])[0]
                        x = self.x[indx]
                        y = self.y[indx]
                        y2 = self.y2[indx]
                        absy = self.absy[indx]
                        self.ly.set_xdata(x)
                        self.marker.set_data([x],[y])
                        self.txt.set_text('t=%1.2f, y=%1.2f, error=%1.6f' % (x, y, absy))
                        self.txt.set_position((x,0.5*y2+0.5*y))
                        self.ax.figure.canvas.draw_idle()
                px_index_list = np.array(px_index_list)
                py_index_list = np.array(py_index_list)
                pz_index_list = np.array(pz_index_list)
                pxd_index_list = np.array(pxd_index_list)
                pyd_index_list = np.array(pyd_index_list)
                pzd_index_list = np.array(pzd_index_list)
                px_thumb_list = np.array(px_thumb_list)
                py_thumb_list = np.array(py_thumb_list)
                pz_thumb_list = np.array(pz_thumb_list)
                pxd_thumb_list = np.array(pxd_thumb_list)
                pyd_thumb_list = np.array(pyd_thumb_list)
                pzd_thumb_list = np.array(pzd_thumb_list)
                fig1, axs1 = plt.subplots(4)
                axs1[0].plot(current_time_list, px_index_list, label='$X_{real}$')
                axs1[0].plot(current_time_list, pxd_index_list, label='$X_{desired}$')
                axs1[0].legend()
                axs1[0].set_xlabel("t / s")
                axs1[0].set_ylabel("X / m")
                axs1[0].set_ylim([min([min(px_index_list),min(pxd_index_list)]), max([max(px_index_list),max(pxd_index_list)])])

                axs1[1].plot(current_time_list, py_index_list, label='$Y_{real}$')
                axs1[1].plot(current_time_list, pyd_index_list, label='$Y_{desired}$')
                axs1[1].legend()
                axs1[1].set_xlabel("t / s")
                axs1[1].set_ylabel("Y / m")
                axs1[1].set_ylim([min([min(py_index_list),min(pyd_index_list)]), max([max(py_index_list),max(pyd_index_list)])])

                axs1[2].plot(current_time_list, pz_index_list, label='$Z_{real}$')
                axs1[2].plot(current_time_list, pzd_index_list, label='$Z_{desired}$')
                axs1[2].legend()
                axs1[2].set_xlabel("t / s")
                axs1[2].set_ylabel("Z / m")
                axs1[2].set_ylim([min([min(pz_index_list),min(pzd_index_list)]), max([max(pz_index_list),max(pzd_index_list)])])

                axs1[3].plot(current_time_list,thetax_index_list,label='$error_{\\theta_X}$')
                axs1[3].plot(current_time_list,thetaz_index_list,label='$error_{\\theta_Z}$')
                axs1[3].set_xlabel("t / s")
                axs1[3].set_ylabel("$\\theta$ / rad")
                axs1[3].set_ylim([min([min(thetax_index_list),min(thetaz_index_list)]), max([max(thetax_index_list),max(thetaz_index_list)])])
                axs1[3].legend()
                #cursor = Cursor(ax)
                cursor1 = SnaptoCursor(axs1[0], current_time_list, px_index_list, pxd_index_list)
                cid1 =  plt.connect('motion_notify_event', cursor1.mouse_move)
                cursor2 = SnaptoCursor(axs1[1], current_time_list, py_index_list, pyd_index_list)
                cid2 =  plt.connect('motion_notify_event', cursor2.mouse_move)
                cursor3 = SnaptoCursor(axs1[2], current_time_list, pz_index_list, pzd_index_list)
                cid3 =  plt.connect('motion_notify_event', cursor3.mouse_move)

                fig2, axs2 = plt.subplots(4)
                axs2[0].plot(current_time_list, px_thumb_list, label='$X_{real}$')
                axs2[0].plot(current_time_list, pxd_thumb_list, label='$X_{desired}$')
                axs2[0].legend()
                axs2[0].set_xlabel("t / s")
                axs2[0].set_ylabel("X / m")
                axs2[0].set_ylim([min([min(px_thumb_list),min(pxd_thumb_list)]), max([max(px_thumb_list),max(pxd_thumb_list)])])

                axs2[1].plot(current_time_list, py_thumb_list, label='$Y_{real}$')
                axs2[1].plot(current_time_list, pyd_thumb_list, label='$Y_{desired}$')
                axs2[1].legend()
                axs2[1].set_xlabel("t / s")
                axs2[1].set_ylabel("Y / m")
                axs2[1].set_ylim([min([min(py_thumb_list),min(pyd_thumb_list)]), max([max(py_thumb_list),max(pyd_thumb_list)])])

                axs2[2].plot(current_time_list, pz_thumb_list, label='$Z_{real}$')
                axs2[2].plot(current_time_list, pzd_thumb_list, label='$Z_{desired}$')
                axs2[2].legend()
                axs2[2].set_xlabel("t / s")
                axs2[2].set_ylabel("Z / m")
                axs2[2].set_ylim([min([min(pz_thumb_list),min(pzd_thumb_list)]), max([max(pz_thumb_list),max(pzd_thumb_list)])])

                axs2[3].plot(current_time_list,thetax_thumb_list,label='$error_{\\theta_X}$')
                axs2[3].plot(current_time_list,thetaz_thumb_list,label='$error_{\\theta_Z}$')
                axs2[3].set_xlabel("t / s")
                axs2[3].set_ylabel("$\\theta$ / rad")
                axs2[3].set_ylim([min([min(thetax_thumb_list),min(thetaz_thumb_list)]), max([max(thetax_thumb_list),max(thetaz_thumb_list)])])
                axs2[3].legend()
                #cursor = Cursor(ax)
                cursor4 = SnaptoCursor(axs2[0], current_time_list, px_thumb_list, pxd_thumb_list)
                cid4 =  plt.connect('motion_notify_event', cursor4.mouse_move)
                cursor5 = SnaptoCursor(axs2[1], current_time_list, py_thumb_list, pyd_thumb_list)
                cid5 =  plt.connect('motion_notify_event', cursor5.mouse_move)
                cursor6 = SnaptoCursor(axs2[2], current_time_list, pz_thumb_list, pzd_thumb_list)
                cid6 =  plt.connect('motion_notify_event', cursor6.mouse_move)
                plt.show()
                break
            else:
                current_time_list.append(self.current_time - t0_sin)
                thetax_index_list.append(math.acos(np.matmul(R_index[:,0].T, R_index_current[:,0])))
                thetaz_index_list.append(math.acos(np.matmul(R_index[:,2].T, R_index_current[:,2])))
                thetax_thumb_list.append(math.acos(np.matmul(R_thumb[:,0].T, R_thumb_current[:,0])))
                thetaz_thumb_list.append(math.acos(np.matmul(R_thumb[:,2].T, R_thumb_current[:,2])))
                px_index_list.append(p_index_current[0,0])
                py_index_list.append(p_index_current[1,0])
                pz_index_list.append(p_index_current[2,0])
                pxd_index_list.append(p_index[0,0])
                pyd_index_list.append(p_index[1,0])
                pzd_index_list.append(p_index[2,0])
                px_thumb_list.append(p_thumb_current[0,0])
                py_thumb_list.append(p_thumb_current[1,0])
                pz_thumb_list.append(p_thumb_current[2,0])
                pxd_thumb_list.append(p_thumb[0,0])
                pyd_thumb_list.append(p_thumb[1,0])
                pzd_thumb_list.append(p_thumb[2,0])

            rospy.sleep(0.003)
            self.save_time()
        rospy.signal_shutdown("Exit...")

if __name__ == '__main__':
    # Init node (In one python script, node can only be inited once.)
    rospy.init_node('sub_calc_pub_node', anonymous=True, log_level=rospy.WARN)
    my_controller = MyController()
    my_controller.main_process()
